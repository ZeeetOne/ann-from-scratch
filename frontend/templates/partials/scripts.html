<script>
    // Theme Toggle
    const themeToggle = document.getElementById('themeToggle');
    const html = document.documentElement;

    // Load saved theme
    const savedTheme = localStorage.getItem('theme') || 'light';
    html.setAttribute('data-theme', savedTheme);
    themeToggle.checked = savedTheme === 'dark';

    themeToggle.addEventListener('change', (e) => {
        const theme = e.target.checked ? 'dark' : 'light';
        html.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
    });

    // Tab Navigation Handler
    document.addEventListener('DOMContentLoaded', () => {
        // Map hash to tab IDs
        const tabMap = {
            '#build': 'tab-build',
            '#dataset': 'tab-dataset',
            '#forward': 'tab-forward',
            '#loss': 'tab-loss',
            '#epoch': 'tab-epoch',
            '#train': 'tab-train',
            '#results': 'tab-results'
        };

        // Get all navbar links
        const navLinks = document.querySelectorAll('a[href^="#"]');

        navLinks.forEach(link => {
            link.addEventListener('click', (e) => {
                const hash = link.getAttribute('href');
                const tabId = tabMap[hash];

                if (tabId) {
                    e.preventDefault();
                    const tabRadio = document.getElementById(tabId);
                    if (tabRadio) {
                        tabRadio.checked = true;
                        // Scroll to top of tab content
                        setTimeout(() => {
                            const tabContent = tabRadio.nextElementSibling;
                            if (tabContent) {
                                tabContent.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            }
                        }, 100);
                    }
                }
            });
        });
    });

    // Toast Notification Function
    function showToast(message, type = 'info') {
        const toastContainer = document.getElementById('toastContainer');
        const iconMap = {
            'success': 'fa-check-circle',
            'error': 'fa-exclamation-circle',
            'info': 'fa-info-circle',
            'warning': 'fa-exclamation-triangle'
        };

        const toast = document.createElement('div');
        toast.className = `alert alert-${type} shadow-lg`;
        toast.innerHTML = `
            <div>
                <i class="fas ${iconMap[type]}"></i>
                <span>${message}</span>
            </div>
        `;

        toastContainer.appendChild(toast);

        setTimeout(() => {
            toast.style.opacity = '0';
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }

    // Update step progress
    function updateStep(stepNumber) {
        for (let i = 1; i <= 7; i++) {
            const step = document.getElementById(`step${i}`);
            if (i <= stepNumber) {
                step.classList.add('step-primary');
            } else {
                step.classList.remove('step-primary');
            }
        }

        // Update step description
        updateStepDescription(stepNumber);

        // Show toast for step completion
        const stepMessages = {
            1: '✅ Step 1 Complete: Network architecture built!',
            2: '✅ Step 2 Complete: Dataset loaded!',
            3: '✅ Step 3 Complete: Forward pass executed!',
            4: '✅ Step 4 Complete: Loss calculated!',
            5: '✅ Step 5 Complete: Epoch summary generated! See backpropagation & weight updates.',
            6: '✅ Optional Step: Automated training completed!',
            7: '✅ Optional Step: View comprehensive results and metrics!'
        };

        if (stepMessages[stepNumber]) {
            showToast(stepMessages[stepNumber], 'success');
        }
    }

    // Update step description text
    function updateStepDescription(stepNumber) {
        const descriptions = {
            1: 'Next: Load or generate a dataset that matches your network architecture.',
            2: 'Next: Run Forward Pass to see how your network makes predictions.',
            3: 'Next: Calculate Loss to measure prediction error.',
            4: 'Next: View Epoch Summary to see complete training cycle (Backprop → Update → New Loss).',
            5: 'Excellent! You completed 1 epoch and saw the full learning cycle. Now you can: (1) Repeat for more epochs, or (2) Use Automated Training for multiple epochs.',
            6: 'Optional: View comprehensive training metrics, loss curves, and model performance in Results tab.',
            7: 'All done! Analyze results and experiment with different architectures or hyperparameters.'
        };

        const descText = document.getElementById('stepDescriptionText');
        if (descText && descriptions[stepNumber]) {
            descText.textContent = descriptions[stepNumber];
        }
    }

    // Initialize Loss Chart
    let lossChart = null;

    function initializeLossChart() {
        const ctx = document.getElementById('lossChart');
        if (!ctx) return;

        if (lossChart) {
            lossChart.destroy();
        }

        lossChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Training Loss',
                    data: [],
                    borderColor: 'rgb(147, 51, 234)',
                    backgroundColor: 'rgba(147, 51, 234, 0.1)',
                    tension: 0.4,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top'
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Loss'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Epoch'
                        }
                    }
                }
            }
        });
    }


    // Initialize loss chart on page load
    document.addEventListener('DOMContentLoaded', () => {
        console.log('Initializing loss chart...');
        initializeLossChart();

        // Re-initialize chart when Results tab is opened
        const resultsTab = document.getElementById('tab-results');
        if (resultsTab) {
            resultsTab.addEventListener('change', () => {
                if (resultsTab.checked) {
                    console.log('Results tab opened, re-rendering chart...');
                    // Small delay to ensure container is visible
                    setTimeout(() => {
                        if (lossChart) lossChart.resize();
                    }, 100);
                }
            });
        }
    });

    // Helper function to update loss chart
    function updateCharts(history) {
        console.log('updateCharts called with history:', history);

        if (!history || !history.loss) {
            console.warn('No history or loss data available');
            return;
        }

        // Update loss chart
        if (lossChart) {
            const epochs = history.loss.map((_, i) => i + 1);
            lossChart.data.labels = epochs;
            lossChart.data.datasets[0].data = history.loss;
            lossChart.update();
            console.log('Loss chart updated with', history.loss.length, 'data points');
        } else {
            console.warn('lossChart not initialized');
        }
    }

    // Note: Generate Random Dataset button removed to avoid confusion
    // Users can use "Load Example Dataset" for educational datasets
    // or upload their own CSV files
</script>

<!-- ES6 Module: Main application with imports -->
<script type="module" src="{{ url_for('static', filename='js/app.js') }}"></script>
